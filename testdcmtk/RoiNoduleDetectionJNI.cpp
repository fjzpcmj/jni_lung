/* DO NOT EDIT THIS FILE - it is machine generated */
#include <iostream>
#include "RoiNoduleDetectionJNI.h"

#include "detection.h"
#include <time.h>
#include <windows.h>



using namespace std;
//using namespace cv;
char * JStringToCharArray(JNIEnv * pJNIEnv, jstring jstr);
/*
* Class:     com_navitek_jni_RoiNoduleDetection
* Method:    SemiAutoLungNodulesDetection
* Signature: (Ljava/lang/String;Lcom/navitek/jni/RegionInfo;[Z[S)Ljava/util/ArrayList;
*/
JNIEXPORT jobject JNICALL Java_com_navitek_jni_RoiNoduleDetection_SemiAutoLungNodulesDetection
(JNIEnv * env, jobject obj, jstring dFilePath, jobject roiReginInfo, jbooleanArray tagOutsideLungMap, jintArray tag3DRawImg)
{
	
	//const char* pname = env->GetStringUTFChars(dFilePath, NULL);
	const char* pname = JStringToCharArray(env, dFilePath);
	jclass roiReginInfo_class = env->GetObjectClass(roiReginInfo);
	
	jmethodID getxMin_methodID = env->GetMethodID(roiReginInfo_class, "getxMin", "()I");
	int xMin = (jint)env->CallObjectMethod(roiReginInfo, getxMin_methodID);
	jmethodID getxMax_methodID = env->GetMethodID(roiReginInfo_class, "getxMax", "()I");
	int xMax = (jint)env->CallObjectMethod(roiReginInfo, getxMax_methodID);
	jmethodID getyMin_methodID = env->GetMethodID(roiReginInfo_class, "getyMin", "()I");
	int yMin = (jint)env->CallObjectMethod(roiReginInfo, getyMin_methodID);
	jmethodID getyMax_methodID = env->GetMethodID(roiReginInfo_class, "getyMax", "()I");
	int yMax = (jint)env->CallObjectMethod(roiReginInfo, getyMax_methodID);
	jmethodID ggetzMin_methodID = env->GetMethodID(roiReginInfo_class, "getzMin", "()I");
	int zMin = (jint)env->CallObjectMethod(roiReginInfo, ggetzMin_methodID);
	jmethodID getzMax_methodID = env->GetMethodID(roiReginInfo_class, "getzMax", "()I");
	int zMax = (jint)env->CallObjectMethod(roiReginInfo, getzMax_methodID);

	jmethodID getxDim_methodID = env->GetMethodID(roiReginInfo_class, "getxDim", "()I");
	int xDim = (jint)env->CallObjectMethod(roiReginInfo, getxDim_methodID);
	jmethodID getyDim_methodID = env->GetMethodID(roiReginInfo_class, "getyDim", "()I");
	int yDim = (jint)env->CallObjectMethod(roiReginInfo, getyDim_methodID);
	jmethodID getzDim_methodID = env->GetMethodID(roiReginInfo_class, "getzDim", "()I");
	int zDim = (jint)env->CallObjectMethod(roiReginInfo, getzDim_methodID);

	//TAG值的启示位置
	jmethodID getMaxNoduleTag_methodID = env->GetMethodID(roiReginInfo_class, "getMaxNoduleTag", "()I");
	int maxNoduleTag = (jint)env->CallObjectMethod(roiReginInfo, getMaxNoduleTag_methodID);

	//上面传输过来的x/y/z分别都是原图的！
	int roiXDim = xMax - xMin + 1;
	int roiYDim = yMax - yMin + 1;
	int roiZDim = zMax - zMin + 1;
	int roiSize = roiXDim*roiYDim*roiZDim;

	jmethodID getDxVoxel_methodID = env->GetMethodID(roiReginInfo_class, "getDxVoxel", "()F");
	float dxVoxel = (jfloat)env->CallFloatMethod(roiReginInfo, getDxVoxel_methodID);
	jmethodID getDyVoxel_methodID = env->GetMethodID(roiReginInfo_class, "getDyVoxel", "()F");
	float dyVoxel = (jfloat)env->CallFloatMethod(roiReginInfo, getDyVoxel_methodID);
	jmethodID getDzVoxel_methodID = env->GetMethodID(roiReginInfo_class, "getDzVoxel", "()F");
	float dzVoxel = (jfloat)env->CallFloatMethod(roiReginInfo, getDzVoxel_methodID);

	jint *Raw3DImg = env->GetIntArrayElements(tag3DRawImg, false);

	

	//识别圈中区域的结节

	string path = pname;// "FANG_XIN_FU/";
	//int xMin = 356; 
	//int xMax = 374; 
	//int yMin = 223; 
	//int yMax = 243; 
	//int zMin = 55; 
	//int zMax = 64;1
	string logpath = path + "log.txt";
	ofstream log(logpath, ios::app);
	//log << "zMin:" << zMin << "zMax" << zMax;
	clock_t start, mid0, mid1, mid2, mid3, end,inside;

	start = clock();

	//vector<string> filename;
	//vector<cv::Mat> CTImgs;
	//vector<cv::Mat> CTROIImgs;
	//vector<cv::Mat> NoduleTagMaps;
	vector<cv::Mat> NoduleTag_Res;
	vector<bool> NoduleFlag;
	bool NoduleInside = true; //true 代表在肺内
	//DicomImage *DICM;
	//int roiXDim = xMax - xMin + 1;
	//int roiYDim = yMax - yMin + 1;
	//int roiZDim = zMax - zMin + 1;
	cv::Mat temp;
	mid0 = clock();
	//filename = getAllFileNames(path);
	//for (int i = 0; i < filename.size(); i++){
	//	//cout << filename[i] << endl;
	//	if (i >= zMin && i <= zMax){
	//		DICM = new DicomImage((path + filename[i]).c_str());
	//		DcmToMat(DICM, temp);
	//	}		
	//	CTImgs.push_back(temp);
	//}
	vector<cv::Mat> img3D;
	arrrayToMat(Raw3DImg, img3D, roiXDim, roiYDim, roiZDim);
	env->ReleaseIntArrayElements(tag3DRawImg, Raw3DImg, 0);
	log << "read dcm time (sec) :" << static_cast<double>(clock() - mid0) / CLOCKS_PER_SEC ;
	//imwrite("FANG_XIN_FU/NoduleTag/000.jpg", CTImgs[55]);
	//cout << CTImgs.size() << endl;
	//imshow("CT", CTImgs[5]);
	cv::Rect rect = cv::Rect(xMin, yMin, roiXDim, roiYDim);
	Lungdetection det;
	//det.SetImg(img3D[0], rect, path, 0 + zMin, zDim);
	//det.NoduleSeg();
	mid1 = clock();
	//cmj 整个序号要改动
	//log << "img3D.size:" << img3D.size() ;
	//log << "xMin:" << xMin << "yMin"<<yMin << endl;
	//log << "zDim:" << zDim << endl;
	//log << "path:" << path << endl;
	for (int i = 0; i < img3D.size(); i++){
		//log << "idx:" << i + zMin<<endl;
		//inside = clock();
		det.SetImg(img3D[i], rect, path, i + zMin, zDim);
		//det.LungSeg();//先是识别出肺部区域
		det.NoduleSeg();//分割方框内结节
		//NoduleTagMaps.push_back(det.getNoduleTag());//这个TagMap大小与CT图像的大小一致
		NoduleTag_Res.push_back(det.getNoduleTag_Res());//这个TagMap大小与框的大小一致
		NoduleFlag.push_back(det.segmented);
		NoduleInside = det.insideLung & NoduleInside;
		//log << "det.segmented" <<i <<" : "<< det.segmented<<endl;
		//CTROIImgs.push_back(img3D[i].clone());//框区域内的原图
		//log << "NoduleSeg each slice time (sec) :" << static_cast<double>(clock() - inside) / CLOCKS_PER_SEC<<endl;
	}
	vector<cv::Mat> ErodeOut;
	vector<cv::Mat> DialateOut;
	Bin3DMorphologyErode(NoduleTag_Res, ErodeOut);
	Bin3DMorphologyDialate(ErodeOut, DialateOut);
	for (int i = 0; i < DialateOut.size(); i++){
		morphologyEx(DialateOut[i], DialateOut[i], cv::MORPH_DILATE, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5)));
		NoduleTag_Res[i] = DialateOut[i] & NoduleTag_Res[i];//做交集
	}
	log << "NoduleSeg time (sec) :" << static_cast<double>(clock() - mid1) / CLOCKS_PER_SEC ;

	//cv::waitKey();
	

	//返回结节信息list
	mid2 = clock();
	jclass arrayList_cls = env->FindClass("Ljava/util/ArrayList;");
	if (arrayList_cls == NULL)
	{
		cerr << "ArrayList is null." << endl;
	}
	jmethodID arrayList_costruct = env->GetMethodID(arrayList_cls, "<init>", "()V");
	jobject arrayList_obj = env->NewObject(arrayList_cls, arrayList_costruct);

	jmethodID arrayList_add = env->GetMethodID(arrayList_cls, "add", "(Ljava/lang/Object;)Z");

	int setxMin = 1000, setyMin = 1000, setzMin = 0, setxMax = 0, setyMax = 0, setzMax = 0, setMassCenterX, setMassCenterY, setMassCenterZ, setCount;

	int zMid = (zMin + zMax) / 2 - zMin;
	//int TempMinX, TempMinY, TempMaxX, TempMaxY, TempMinZ, TempMaxZ = 0;
	for (int i = zMid - 1; i < NoduleTag_Res.size(); i++){//从中间处-1的位置开始找
		if (NoduleFlag[i]){

			bool flag = false;//此slice上是否有分割结果
			for (int yindex = 0; yindex < roiYDim; yindex++)
			{
				for (int xindex = 0; xindex < roiXDim; xindex++)
				{

					if (NoduleTag_Res[i].at<uchar>(yindex, xindex)>0)
					{
						flag = true;
						if (yindex>setyMax){
							setyMax = yindex;
						}
						if (yindex<setyMin){
							setyMin = yindex;
						}
						if (xindex>setxMax){
							setxMax = xindex;
						}
						if (xindex<setxMin){
							setxMin = xindex;
						}
					}

				}
			}
			if (!flag){
				break;
			}
			setzMax = i;
		}
		else if (!NoduleFlag[i] && i>zMid){
			break;
		}
	}
	for (int i = zMid + 1; i >= 0; i--){//从中间处+1的位置开始找
		if (NoduleFlag[i]){

			bool flag = false;//此slice上是否有分割结果
			for (int yindex = 0; yindex < roiYDim; yindex++)
			{
				for (int xindex = 0; xindex < roiXDim; xindex++)
				{
					if (NoduleTag_Res[i].at<uchar>(yindex, xindex)>0)
					{
						flag = true;
						if (yindex>setyMax){
							setyMax = yindex;
						}
						if (yindex<setyMin){
							setyMin = yindex;
						}
						if (xindex>setxMax){
							setxMax = xindex;
						}
						if (xindex<setxMin){
							setxMin = xindex;
						}
					}

				}
			}
			if (!flag){
				break;
			}
			setzMin = i;
		}
		else if (!NoduleFlag[i] && i<zMid){
			break;
		}
	}
	//判断是否有结节
	bool NoduleExist = false;
	/*for (int i = 0; i < NoduleFlag.size(); i++){
		NoduleExist = NoduleExist | NoduleFlag[i];
		
	}*/
	if (setzMax > setzMin){
		NoduleExist = true;
	}
	log << "NoduleExist:" << NoduleExist;
	//log << "      setzMin:" << setzMin + zMin << "setzMax" << setzMax + zMin<<endl;
	if (NoduleExist){
			
		string rawName;
		string imgName;
		string nodulePath = path + "NoduleTag\\";
		ifstream fin0(nodulePath);
		//int xDim = CTImgs[zMin].size().width;
		//int yDim = CTImgs[zMin].size().height;
		if (!fin0)//文件不存在
		{
			_mkdir(nodulePath.c_str());
		}

		for (int i = setzMin; i <= setzMax; i++){
			imgName = nodulePath + to_string(i + zMin + 1) + ".jpg";
			rawName = nodulePath + to_string(i + zMin + 1) + ".raw";
			imwrite(imgName, NoduleTag_Res[i]);

			short *tagTmp = new short[xDim*yDim];

			ifstream fin1(rawName);
			if (!fin1)//文件不存在
			{
				//这里应该初始化tagTmp
				for (int h = 0; h < yDim; h++)
				{
					for (int w = 0; w < xDim; w++)
					{
						tagTmp[h*xDim + w] = 0;
					}

				}
			}
			else
			{
				char noduleFileTmp[1024];
				sprintf(noduleFileTmp, rawName.c_str());
				FILE * fidReadRawImg = fopen(noduleFileTmp, "r"); // must be with 'r'.
				fread(tagTmp, sizeof(short), xDim*yDim, fidReadRawImg);
				fclose(fidReadRawImg);
			}

			for (int yindex = 0; yindex < roiYDim; yindex++)
			{
				for (int xindex = 0; xindex < roiXDim; xindex++)
				{
					//这里是对应的roi图中的坐标点的值
					//int regionindex = zindex*roiYDim * roiXDim + yindex * roiXDim + xindex;
					int dataindex = (yindex + yMin)  *  xDim +(xindex + xMin);
					if (NoduleTag_Res[i].at<uchar>(yindex, xindex)>0)
					{
						tagTmp[dataindex] = NoduleTag_Res[i].at<uchar>(yindex, xindex)/255;//NoduleTag_Res内结节的位置用255标识的
					}

				}
			}
			char rawImgData3D[1024];
			sprintf(rawImgData3D, rawName.c_str());
			FILE * fidRawImg = fopen(rawImgData3D, "wb"); // must be with 'b'.
			fwrite(tagTmp, sizeof(short), xDim*yDim, fidRawImg);
			fclose(fidRawImg);

			delete[] tagTmp; tagTmp = NULL;
		}
		log << "write raw time (sec) :" << static_cast<double>(clock() - mid2) / CLOCKS_PER_SEC<<endl;
		//DcmFileFormat fileFormat;
		//double m_pixelSpacingX;
		//double m_pixelSpacingY;
		//double m_sliceThickness;
		double vol = 0;
		double sur = 0;
		vector<cv::Mat> resizedImg;
		//OFCondition status = fileFormat.loadFile((path + filename[0]).c_str());
		//fileFormat.getDataset()->findAndGetFloat64(DCM_PixelSpacing, m_pixelSpacingX, 0);
		//fileFormat.getDataset()->findAndGetFloat64(DCM_PixelSpacing, m_pixelSpacingY, 1);
		//fileFormat.getDataset()->findAndGetFloat64(DCM_SliceThickness, m_sliceThickness);
		resize3D(NoduleTag_Res, resizedImg, dxVoxel, dyVoxel, dzVoxel);
		vol = volume(resizedImg,1);
		sur = surface(resizedImg);
		cout << "volume" << vol << endl;
		cout << "surface" << sur << endl;

		
		double setLobeIndex, setMinHU, setMaxHU, setMean, setSum, setStd, setMaxHUHist, setArea = 0, setVolume = 0, setCompactness;
		int setRoundness, setMaxDiameter, setCountHistMaxPos, setHistogramNorm, setNoduleType;
		double entropy, maocidu;
		double meanHU=0, stdHU=0;
		int maxHU=-2000, minHU=2000;
	//	int maxpixel = -1 , minpixel = 256;
		for (int i = 0; i < setzMin; i++){
			NoduleTag_Res[i].setTo(0);
		}
		for (int i = setzMax + 1; i < NoduleTag_Res.size(); i++){
			NoduleTag_Res[i].setTo(0);
		}
		entropy = CalEntropy3D(img3D, NoduleTag_Res);
		maocidu = CalMaocidu(resizedImg);

		vector<cv::Mat> solid;//255为实性部分,vector大小为setzMax-setzMin+1
		vector<cv::Mat> resizedDst;
		vector<cv::Mat> solidConnect;//实性连通区域，label=1,2,3...
		vector<vector<double>> SolidConnectHuProperty;
		vector<double> SolidConnectVolumeProperty;
		vector<int> SolidVolumeHistogram;
		double volSolid, solidPercent;//solidPercent实性度
		vector<int> useLabel;//连通域分析出来的label
		double diversity;//实性联通分支离散程度
		vector<double> roiXYZDim;
		roiXYZDim.push_back(setxMax - setxMin + 1);
		roiXYZDim.push_back(setyMax - setyMin + 1);
		roiXYZDim.push_back(setzMax - setzMin + 1);

		solidNodule(NoduleTag_Res, img3D, solid);
		icvprCcaByTwoPass3D(solid, solidConnect, useLabel);
		SolidConnectHuProperty = getSolidConnectHuDiversityProperty(solidConnect, NoduleTag_Res, useLabel, roiXYZDim, diversity);
		SolidConnectVolumeProperty = getSolidConnectVolumeProperty(solidConnect, useLabel, dxVoxel, dyVoxel, dzVoxel);

		double xaxis[5] = {0,50, 100, 150, 200};
		vector<double> xAxis(xaxis, xaxis + 5);
		SolidVolumeHistogram = getSolidVolumeHistogram(SolidConnectVolumeProperty, xAxis);


		resize3D(solid, resizedDst, dxVoxel, dyVoxel, dzVoxel);
		volSolid = volume(resizedDst, 1);
		solidPercent = volSolid / (vol + 0.0001);
		int solidCon_num = useLabel.size();//实性联通区域个数


		vector<int> countedPixel;
		for (int i = setzMin; i <= setzMax; i++){
			int pixel;
			if (NoduleFlag[i]){			
				for (int yindex = 0; yindex < roiYDim; yindex++)
				{
					for (int xindex = 0; xindex < roiXDim; xindex++)
					{
						if (NoduleTag_Res[i].at<uchar>(yindex, xindex)>0)
						{
							pixel = img3D[i].at<uchar>(yindex, xindex);
							if (pixel>maxHU){
								maxHU = pixel;
							}
							if (pixel<minHU){
								minHU = pixel;
							}
							countedPixel.push_back(pixel);
							meanHU = pixel + meanHU;
						}
					}
				}
			}
		}
		if (countedPixel.size() != 0){
			meanHU = meanHU / countedPixel.size();
			for (int i = 0; i < countedPixel.size(); i++){
				stdHU = stdHU + (countedPixel[i] - meanHU)*(countedPixel[i] - meanHU);
			}
			stdHU = sqrt(stdHU / countedPixel.size());
		}
		double slope = double(WindowsWidth) / 255;
		double bias = double(WindowsCenter) - double(WindowsWidth) / 2;
		maxHU = slope*maxHU + bias;
		minHU = slope*minHU + bias;
		meanHU = slope*meanHU + bias;
		stdHU = slope*stdHU;

		cout << "maxHU :" << maxHU << "minHU" << minHU;
		setxMin = setxMin + xMin;
		setxMax = setxMax + xMin;
		setyMin = setyMin + yMin;
		setyMax = setyMax + yMin;
		setzMax = setzMax + zMin;
		setzMin = setzMin + zMin;
		setVolume = vol;
		setArea = sur;
		
		int xCenter = (setxMin + setxMax) / 2;
		int yCenter = (setyMin + setyMax) / 2;
		int NodulePosition = 0;//0 :左上 1：右上 2：左下 3：右下
		if (xCenter < (xDim / 2) && yCenter < (yDim / 2)){
			NodulePosition = 0;
		}
		else if (xCenter >(xDim / 2) && yCenter < (yDim / 2)){
			NodulePosition = 1;
		}
		else if (xCenter <(xDim / 2) && yCenter > (yDim / 2)){
			NodulePosition = 2;
		}
		else{
			NodulePosition = 3;
		}

		
		feature NoduleFeature;
		//det.SetImg(CTImgs[(setzMin + setzMax) / 2], rect, path, (setzMin + setzMax) / 2, filename.size());
		//det.NoduleSeg();//分割方框内结节
		double guanghuandu = 0, yuandu = 0;
		cv::Mat featureImg = img3D[(setzMin + setzMax) / 2 - zMin];
		cv::Mat featureMap = NoduleTag_Res[(setzMin + setzMax) / 2 - zMin];
		feature2D(featureImg, featureMap, NoduleFeature);
		NoduleFeature.maxDiameter = dxVoxel*MajorDiameterXY(featureMap);
		NoduleFeature.maxDiameterZ = dzVoxel*(setzMax - setzMin);
		guanghuandu = NoduleFeature.ratio_open;//光滑度
		yuandu = NoduleFeature.M1;//圆度
		//封装返回对象

		jclass nodulesInfo_cls = env->FindClass("com/navitek/jni/NoduleInfo");

		jmethodID nodulesInfo_costruct = env->GetMethodID(nodulesInfo_cls, "<init>", "()V");

		jmethodID setXMin_methodID = env->GetMethodID(nodulesInfo_cls, "setxMin", "(I)V");
		jmethodID setYMin_methodID = env->GetMethodID(nodulesInfo_cls, "setyMin", "(I)V");
		jmethodID setZMin_methodID = env->GetMethodID(nodulesInfo_cls, "setzMin", "(I)V");
		jmethodID setXMax_methodID = env->GetMethodID(nodulesInfo_cls, "setxMax", "(I)V");
		jmethodID setYMax_methodID = env->GetMethodID(nodulesInfo_cls, "setyMax", "(I)V");
		jmethodID setZMax_methodID = env->GetMethodID(nodulesInfo_cls, "setzMax", "(I)V");
		jmethodID setMassCenterX_methodID = env->GetMethodID(nodulesInfo_cls, "setMassCenterX", "(I)V");
		jmethodID setMassCenterY_methodID = env->GetMethodID(nodulesInfo_cls, "setMassCenterY", "(I)V");
		jmethodID setMassCenterZ_methodID = env->GetMethodID(nodulesInfo_cls, "setMassCenterZ", "(I)V");
		jmethodID setCount_methodID = env->GetMethodID(nodulesInfo_cls, "setCount", "(J)V");
		jmethodID setTag_methodID = env->GetMethodID(nodulesInfo_cls, "setTag", "(I)V");
		jmethodID setLobeIndex_methodID = env->GetMethodID(nodulesInfo_cls, "setLobeIndex", "(I)V");
		jmethodID setMinHU_methodID = env->GetMethodID(nodulesInfo_cls, "setMinHU", "(I)V");
		jmethodID setMaxHU_methodID = env->GetMethodID(nodulesInfo_cls, "setMaxHU", "(I)V");
		jmethodID setMean_methodID = env->GetMethodID(nodulesInfo_cls, "setMean", "(F)V");
		jmethodID setSum_methodID = env->GetMethodID(nodulesInfo_cls, "setSum", "(F)V");
		jmethodID setSTD_methodID = env->GetMethodID(nodulesInfo_cls, "setStd", "(F)V");
		jmethodID setMaxHUHist_methodID = env->GetMethodID(nodulesInfo_cls, "setMaxHUHist", "(F)V");
		jmethodID setArea_methodID = env->GetMethodID(nodulesInfo_cls, "setArea", "(F)V");
		jmethodID setVolume_methodID = env->GetMethodID(nodulesInfo_cls, "setVolume", "(F)V");
		jmethodID setCompactness_methodID = env->GetMethodID(nodulesInfo_cls, "setCompactness", "(F)V");
		jmethodID setRoundness_methodID = env->GetMethodID(nodulesInfo_cls, "setRoundness", "(F)V");
		jmethodID setMaxDiameter_methodID = env->GetMethodID(nodulesInfo_cls, "setMaxDiameter", "(F)V");
		jmethodID setCountHistMaxPos_methodID = env->GetMethodID(nodulesInfo_cls, "setCountHistMaxPos", "(I)V");
		jmethodID setHistogramNorm_methodID = env->GetMethodID(nodulesInfo_cls, "setHistogramNorm", "([F)V");
		jmethodID setNoduleType_methodID = env->GetMethodID(nodulesInfo_cls, "setNoduleType", "(I)V");
		//jmethodID setLocalTagMap_methodID = env->GetMethodID(nodulesInfo_cls, "setLocalTagMap", "([Z)V");

		jmethodID setHengzongbi_methodID = env->GetMethodID(nodulesInfo_cls, "setHengzongbi", "(F)V");
		jmethodID setTukedu_methodID = env->GetMethodID(nodulesInfo_cls, "setTukedu", "(F)V");
		jmethodID setEntropy_methodID = env->GetMethodID(nodulesInfo_cls, "setEntropy", "(F)V");
		jmethodID setMaocidu_methodID = env->GetMethodID(nodulesInfo_cls, "setMaocidu", "(F)V");

		jmethodID setMaxDiameterZ_methodID = env->GetMethodID(nodulesInfo_cls, "setMaxDiameterZ", "(F)V");
		/* 实性度、实性联通分支数
		jmethodID setSolidPercent_methodID = env->GetMethodID(nodulesInfo_cls, "setSolidPercent", "(F)V");
		jmethodID setSolidNum_methodID = env->GetMethodID(nodulesInfo_cls, "setSolidNum", "(I)V");
		*/
		/* 结节是否在肺壁，和具体位置，左上右上左下右下
		jmethodID setNoduleInside_methodID = env->GetMethodID(nodulesInfo_cls, "setNoduleInside", "(Z)V");
		jmethodID setNodulePosition_methodID = env->GetMethodID(nodulesInfo_cls, "setNodulePosition", "(I)V");
		*/

		

		jobject nodulesInfo_cls_tmp = env->NewObject(nodulesInfo_cls, nodulesInfo_costruct);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setXMin_methodID, setxMin);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setYMin_methodID, setyMin);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setZMin_methodID, setzMin);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setXMax_methodID, setxMax);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setYMax_methodID, setyMax);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setZMax_methodID, setzMax);

		env->CallVoidMethod(nodulesInfo_cls_tmp, setHengzongbi_methodID, NoduleFeature.M4);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setTukedu_methodID, NoduleFeature.M5);

		env->CallVoidMethod(nodulesInfo_cls_tmp, setMaxDiameter_methodID, NoduleFeature.maxDiameter);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setMaxDiameterZ_methodID, NoduleFeature.maxDiameterZ);

		env->CallVoidMethod(nodulesInfo_cls_tmp, setEntropy_methodID, entropy);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setMaocidu_methodID, maocidu);
		/* 实性度、实性联通分支数
		env->CallVoidMethod(nodulesInfo_cls_tmp, setSolidPercent_methodID, solidPercent);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setSolidNum_methodID, solidCon_num);
		*/
		/* 结节是否在肺壁，和具体位置，左上右上左下右下
		env->CallVoidMethod(nodulesInfo_cls_tmp, setNoduleInside_methodID, NoduleInside);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setNodulePosition_methodID, NodulePosition);
		*/


		//env->CallVoidMethod(nodulesInfo_cls_tmp, setMassCenterX_methodID, tmpRoi->massCtr.x);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setMassCenterY_methodID, tmpRoi->massCtr.y);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setMassCenterZ_methodID, tmpRoi->massCtr.z);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setCount_methodID, jlong_count); 


		//env->CallVoidMethod(nodulesInfo_cls_tmp, setTag_methodID, ((tmpRoi->Tag) + maxNoduleTag));
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setLobeIndex_methodID, tmpRoi->Lobe);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setMinHU_methodID, minHU);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setMaxHU_methodID, maxHU);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setMean_methodID, meanHU);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setSum_methodID, tmpRoi->Sum);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setSTD_methodID, stdHU);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setMaxHUHist_methodID, tmpRoi->HistMaxHU);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setArea_methodID, setArea);
		env->CallVoidMethod(nodulesInfo_cls_tmp, setVolume_methodID, setVolume);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setCompactness_methodID, tmpRoi->Compactness);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setRoundness_methodID, tmpRoi->Roundness);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setMaxDiameter_methodID, tmpRoi->MaxDiameter);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setCountHistMaxPos_methodID, tmpRoi->m_HistCountAtMax);
		//env->CallVoidMethod(nodulesInfo_cls_tmp, setNoduleType_methodID, tmpRoi->m_iNoduleType);

		env->CallBooleanMethod(arrayList_obj, arrayList_add, nodulesInfo_cls_tmp);


	}	
	
	//env->ReleaseStringUTFChars(dFilePath, pname);
	cout << "algorithm return ok." << endl;
	return arrayList_obj;


}

char * JStringToCharArray(JNIEnv * pJNIEnv, jstring jstr)
{
	jsize len = pJNIEnv->GetStringLength(jstr);
	const jchar * jcstr = pJNIEnv->GetStringChars(jstr, NULL);

	int size = 0;
	char * str = (char *)malloc(len * 2 + 1);
	if ((size = WideCharToMultiByte(CP_ACP, 0, LPCWSTR(jcstr), len, str, len * 2 + 1, NULL, NULL)) == 0)
		return NULL;

	pJNIEnv->ReleaseStringChars(jstr, jcstr);

	str[size] = 0;
	return str;
}

